var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#Integrals","page":"Public API","title":"Integrals","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"MeshIntegrals.integral","category":"page"},{"location":"api/#MeshIntegrals.integral","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, geometry)\nintegral(f, geometry, algorithm)\nintegral(f, geometry, algorithm, FP)\n\nNumerically integrate a given function f(::Point) over the domain defined by a geometry using a particular integration algorithm with floating point precision of type FP.\n\n\n\n\n\n","category":"function"},{"location":"api/#Aliases","page":"Public API","title":"Aliases","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"MeshIntegrals.lineintegral\nMeshIntegrals.surfaceintegral\nMeshIntegrals.volumeintegral","category":"page"},{"location":"api/#MeshIntegrals.lineintegral","page":"Public API","title":"MeshIntegrals.lineintegral","text":"lineintegral(f, geometry)\nlineintegral(f, geometry, algorithm)\nlineintegral(f, geometry, algorithm, FP)\n\nNumerically integrate a given function f(::Point) along a line-like geometry using a particular integration algorithm with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod (default)\nGaussLegendre\nHAdaptiveCubature\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.surfaceintegral","page":"Public API","title":"MeshIntegrals.surfaceintegral","text":"surfaceintegral(f, geometry)\nsurfaceintegral(f, geometry, algorithm)\nsurfaceintegral(f, geometry, algorithm, FP)\n\nNumerically integrate a given function f(::Point) along a surface geometry using a particular integration algorithm with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.volumeintegral","page":"Public API","title":"MeshIntegrals.volumeintegral","text":"volumeintegral(f, geometry)\nvolumeintegral(f, geometry, algorithm)\nvolumeintegral(f, geometry, algorithm, FP)\n\nNumerically integrate a given function f(::Point) throughout a volumetric geometry using a particular integration algorithm with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-Algorithms","page":"Public API","title":"Integration Algorithms","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"MeshIntegrals.GaussKronrod\nMeshIntegrals.GaussLegendre\nMeshIntegrals.HAdaptiveCubature","category":"page"},{"location":"api/#MeshIntegrals.GaussKronrod","page":"Public API","title":"MeshIntegrals.GaussKronrod","text":"GaussKronrod(kwargs...)\n\nNumerically integrate using the h-adaptive Gauss-Kronrod quadrature rule implemented by QuadGK.jl. All standard QuadGK.quadgk keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.GaussLegendre","page":"Public API","title":"MeshIntegrals.GaussLegendre","text":"GaussLegendre(n)\n\nNumerically integrate using an n'th-order Gauss-Legendre quadrature rule. nodes and weights are efficiently calculated using FastGaussQuadrature.jl.\n\nSo long as the integrand function can be well-approximated by a polynomial of order 2n-1, this method should yield results with 16-digit accuracy in O(n) time. If the function is know to have some periodic content, then n should (at a minimum) be greater than the expected number of periods over the geometry, e.g. length(geometry)/lambda.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.HAdaptiveCubature","page":"Public API","title":"MeshIntegrals.HAdaptiveCubature","text":"GaussKronrod(kwargs...)\n\nNumerically integrate areas and surfaces using the h-adaptive cubature rule implemented by HCubature.jl. All standard HCubature.hcubature keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"triangle/#Integrating-a-Triangle","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"","category":"section"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"For a specified Meshes.Triangle surface with area A, let u and v be Barycentric coordinates that span the surface.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_triangle f(barr)  textdA\n    = iint_triangle fleft( barr(uv) right)  left( textdu wedge textdv right)","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"Since the geometric transformation from the originally-arbitrary domain to a Barycentric domain is linear, the magnitude of the surface element textdu wedge textdv is constant throughout the integration domain. This constant will be equal to twice the magnitude of A.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_triangle f(barr)  textdA\n    = 2A int_0^1 int_0^1-v fleft( barr(uv) right)  textdu  textdv","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"This non-rectangular Barycentric domain prevents a direct application of most numerical integration methods. It can be directly integrated, albeit inefficiently, using nested Gauss-Kronrod quadrature rules. Alternatively, additional transformation could be applied to map this domain onto a rectangular domain.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"WORK IN PROGRESS: continued derivation to detail this barycentric-rectangular domain transformation","category":"page"},{"location":"usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"usage/#Integrating-along-a-Bezier-curve","page":"Example Usage","title":"Integrating along a Bezier curve","text":"","category":"section"},{"location":"usage/","page":"Example Usage","title":"Example Usage","text":"using Meshes\nusing MeshIntegrals\n\n# Define a unit circle on the xy-plane\norigin = Point(0,0,0)\nẑ = Vec(0,0,1)\nxy_plane = Plane(origin,ẑ)\nunit_circle_xy = Circle(xy_plane, 1.0)\n\n# Approximate unit_circle_xy with a high-order Bezier curve\nunit_circle_bz = BezierCurve(\n    [Point(cos(t), sin(t), 0.0) for t in range(0,2pi,length=361)]\n)\n\n# A Real-valued function\nf(x, y, z) = abs(x + y)\nf(p) = f(to(p)...)\n\nintegral(f, unit_circle_xy, GaussKronrod())\n    # 0.000170 seconds (5.00 k allocations: 213.531 KiB)\n    # ans == 5.656854249525293 m^2\n\nintegral(f, unit_circle_bz, GaussKronrod())\n    # 0.017122 seconds (18.93 k allocations: 78.402 MiB)\n    # ans = 5.551055333711397 m^2","category":"page"},{"location":"supportmatrix/#Support-Matrix","page":"Support Matrix","title":"Support Matrix","text":"","category":"section"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"While this library aims to support all possible integration algorithms and Meshes.jl geometry types, some combinations are ill-suited and some others are simplu not yet implemented. The following Support Matrix aims to capture the current development state of all geometry/algorithm combinations. Entries with a green check mark are fully supported and have passing unit tests that provide some confidence they produce accurate results.","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"In general, Gauss-Kronrod integration rules are recommended (and the default) for geometries with one parametric dimension, e.g.: Segment, BezierCurve, and Rope. Gauss-Kronrod rules can also be applied to some geometries with more dimensions by nesting multiple integration solves, but this is inefficient. These Gauss-Kronrod rules are supported (but not recommended) for surface-like geometries, but not for volume-like geometries. For geometries with more than one parametric dimension, e.g. surfaces and volumes, H-Adaptive Cubature integration rules are recommended (and the default).","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Symbol Support Level\n✅ Supported, passes unit tests\n🎗️ Planned to support in the future\n🛑 Not supported","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Meshes.Geometry Gauss-Legendre Gauss-Kronrod H-Adaptive Cubature\nBall in 𝔼{2} ✅ ✅ ✅\nBall in 𝔼{3} ✅ 🛑 ✅\nBezierCurve ✅ ✅ ✅\nBox in 𝔼{1} ✅ ✅ ✅\nBox in 𝔼{2} ✅ ✅ ✅\nBox in 𝔼{3} ✅ 🛑 ✅\nCircle ✅ ✅ ✅\nCone ✅ ✅ ✅\nConeSurface ✅ ✅ ✅\nCylinder ✅ 🛑 ✅\nCylinderSurface ✅ ✅ ✅\nDisk ✅ ✅ ✅\nFrustum 🛑 🛑 🛑\nFrustumSurface 🛑 🛑 🛑\nLine ✅ ✅ ✅\nParaboloidSurface ✅ ✅ ✅\nPlane ✅ ✅ ✅\nRay ✅ ✅ ✅\nRing ✅ ✅ ✅\nRope ✅ ✅ ✅\nSegment ✅ ✅ ✅\nSimpleMesh 🎗️ 🎗️ 🎗️\nSphere in 𝔼{2} ✅ ✅ ✅\nSphere in 𝔼{3} ✅ ✅ ✅\nTetrahedron in 𝔼{3} 🎗️ ✅ 🎗️\nTriangle ✅ ✅ ✅\nTorus ✅ ✅ ✅","category":"page"},{"location":"#MeshIntegrals.jl","page":"About","title":"MeshIntegrals.jl","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: License: MIT) (Image: ColPrac)","category":"page"},{"location":"","page":"About","title":"About","text":"(Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA)","category":"page"},{"location":"","page":"About","title":"About","text":"MeshIntegrals.jl is a Julia library that leverages differential forms to implement fast and easy numerical integration of field equations over geometric domains.","category":"page"}]
}
