var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = MeshIntegrals","category":"page"},{"location":"api/#Integrals","page":"Public API","title":"Integrals","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integral.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.integral","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, geometry[, rule]; diff_method=_default_method(geometry), FP=Float64)\n\nNumerically integrate a given function f(::Point) over the domain defined by a geometry using a particular numerical integration rule with floating point precision of type FP.\n\nArguments\n\nf: an integrand function with a method f(::Meshes.Point)\ngeometry: some Meshes.Geometry that defines the integration domain\nrule: optionally, the IntegrationRule used for integration (by default\n\nGaussKronrod() in 1D and HAdaptiveCubature() else)\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = _default_method(geometry): the method to\n\nuse for calculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired.\n\n\n\n\n\n","category":"function"},{"location":"api/#Specializations","page":"Public API","title":"Specializations","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = Main.SPECIALIZATIONS_FILES","category":"page"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{T}, Tuple{DM}, Tuple{F}, Tuple{F, Meshes.BezierCurve, GaussLegendre}} where {F<:Function, DM<:DifferentiationMethod, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, curve::BezierCurve, rule = GaussKronrod();\n         diff_method=Analytical(), FP=Float64, alg=Meshes.Horner())\n\nLike integral but integrates along the domain defined by curve.\n\nArguments\n\nf: an integrand function with a method f(::Meshes.Point)\ncurve: a BezierCurve that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = Analytical(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\nalg = Meshes.Horner():  the method to use for parameterizing curve. Alternatively,\n\nalg=Meshes.DeCasteljau() can be specified for increased accuracy, but comes with a steep performance cost, especially for curves with a large number of control points.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{F}, Tuple{F, Meshes.Ring, I}} where {F<:Function, I<:IntegrationRule}","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, ring::Ring, rule = GaussKronrod();\n         diff_method=FiniteDifference(), FP=Float64)\n\nLike integral but integrates along the domain defined by ring. The specified integration rule is applied independently to each segment formed by consecutive points in the Ring.\n\nArguments\n\nf: an integrand function with a method f(::Meshes.Point)\nring: a Ring that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = FiniteDifference(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{F}, Tuple{F, Meshes.Rope, I}} where {F<:Function, I<:IntegrationRule}","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, rope::Rope, rule = GaussKronrod();\n         diff_method=FiniteDifference(), FP=Float64)\n\nLike integral but integrates along the domain defined by rope. The specified integration rule is applied independently to each segment formed by consecutive points in the Rope.\n\nArguments\n\nf: an integrand function with a method f(::Meshes.Point)\nrope: a Rope that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = FiniteDifference(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\n\n\n\n\n\n","category":"method"},{"location":"api/#Aliases","page":"Public API","title":"Aliases","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integral_aliases.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.lineintegral","page":"Public API","title":"MeshIntegrals.lineintegral","text":"lineintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a line-like geometry using a particular numerical integration rule with floating point precision of type FP.\n\nRule types available:\n\nGaussKronrod (default)\nGaussLegendre\nHAdaptiveCubature\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.surfaceintegral","page":"Public API","title":"MeshIntegrals.surfaceintegral","text":"surfaceintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a surface geometry using a particular numerical integration rule with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.volumeintegral","page":"Public API","title":"MeshIntegrals.volumeintegral","text":"volumeintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) throughout a volumetric geometry using a particular numerical integration rule with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-Rules","page":"Public API","title":"Integration Rules","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integration_rules.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.GaussKronrod","page":"Public API","title":"MeshIntegrals.GaussKronrod","text":"GaussKronrod(kwargs...)\n\nThe h-adaptive Gauss-Kronrod quadrature rule implemented by QuadGK.jl. All standard QuadGK.quadgk keyword arguments are supported. This rule works natively for one dimensional geometries; some two- and three-dimensional geometries are additionally supported using nested integral solvers with the specified kwarg settings.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.GaussLegendre","page":"Public API","title":"MeshIntegrals.GaussLegendre","text":"GaussLegendre(n)\n\nAn n'th-order Gauss-Legendre quadrature rule. Nodes and weights are efficiently calculated using FastGaussQuadrature.jl.\n\nSo long as the integrand function can be well-approximated by a polynomial of order 2n-1, this method should yield results with 16-digit accuracy in O(n) time. If the function is know to have some periodic content, then n should (at a minimum) be greater than the expected number of periods over the geometry, e.g. length(geometry)/Î».\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.HAdaptiveCubature","page":"Public API","title":"MeshIntegrals.HAdaptiveCubature","text":"HAdaptiveCubature(kwargs...)\n\nThe h-adaptive cubature rule implemented by HCubature.jl. All standard HCubature.hcubature keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#Derivatives","page":"Public API","title":"Derivatives","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"differentiation.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.Analytical","page":"Public API","title":"MeshIntegrals.Analytical","text":"Analytical()\n\nUse to specify use of analytically-derived solutions for calculating derivatives. These solutions are currently defined only for a subset of geometry types.\n\nSupported Geometries:\n\nBezierCurve\nLine\nPlane\nRay\nTetrahedron\nTriangle\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.AutoEnzyme","page":"Public API","title":"MeshIntegrals.AutoEnzyme","text":"AutoEnzyme()\n\nUse to specify use of the Enzyme.jl for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.DifferentiationMethod","page":"Public API","title":"MeshIntegrals.DifferentiationMethod","text":"DifferentiationMethod\n\nA category of types used to specify the desired method for calculating derivatives. Derivatives are used to form Jacobian matrices when calculating the differential element size throughout the integration region.\n\nSee also FiniteDifference, Analytical.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.FiniteDifference","page":"Public API","title":"MeshIntegrals.FiniteDifference","text":"FiniteDifference(Îµ=1e-6)\n\nUse to specify use of a finite-difference approximation method with a step size of Îµ for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.differential-Union{Tuple{V}, Tuple{G}, Tuple{G, V}, Tuple{G, V, DifferentiationMethod}} where {G<:Meshes.Geometry, V<:Union{Tuple, AbstractVector}}","page":"Public API","title":"MeshIntegrals.differential","text":"differential(geometry, ts[, diff_method])\n\nCalculate the differential element (length, area, volume, etc) of the parametric function for geometry at arguments ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.jacobian-Union{Tuple{V}, Tuple{G}, Tuple{G, V}} where {G<:Meshes.Geometry, V<:Union{Tuple, AbstractVector}}","page":"Public API","title":"MeshIntegrals.jacobian","text":"jacobian(geometry, ts[, diff_method])\n\nCalculate the Jacobian of a geometry's parametric function at some point ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"triangle/#Integrating-a-Triangle","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"","category":"section"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"For a specified Meshes.Triangle surface with area A, let u and v be Barycentric coordinates that span the surface.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_triangle f(barr)  textdA\n    = iint_triangle fleft( barr(uv) right)  left( textdu wedge textdv right)","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"Since the geometric transformation from the originally-arbitrary domain to a Barycentric domain is linear, the magnitude of the surface element textdu wedge textdv is constant throughout the integration domain. This constant will be equal to twice the magnitude of A.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_triangle f(barr)  textdA\n    = 2A int_0^1 int_0^1-v fleft( barr(uv) right)  textdu  textdv","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"Since the integral domain is a right-triangle in the Barycentric domain, a nested application of Gauss-Kronrod quadrature rules is capable of computing the result, albeit inefficiently. However, many numerical integration methods that require rectangular bounds can not be directly applied.","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"In order to enable integration methods that operate over rectangular bounds, two coordinate system transformations are applied: the first maps from Barycentric coordinates (u v) to polar coordinates (r phi), and the second is a non-linear map from polar coordinates to a new curvilinear basis (R phi).","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"For the first transformation, let u = rcosphi and v = rsinphi where textdutextdv = rtextdrtextdphi. The Barycentric triangle's hypotenuse boundary line is described by the function v(u) = 1 - u. Substituting in the previous definitions leads to a new boundary line function in polar coordinate space r(phi) = 1  (sinphi + cosphi).","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_0^1 int_0^1-v fleft( barr(uv) right)  textdu  textdv =\n    int_0^pi2 int_0^1(sinphi+cosphi) fleft( barr(rphi) right)  r  textdr  textdphi","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"These integral boundaries remain non-rectangular, so an additional transformation will be applied to a curvilinear (R phi) space that normalizes all of the hypotenuse boundary line points to R=1. To achieve this, a function R(rphi) is required such that R(r_0 phi) = 1 where r_0 = 1  (sinphi + cosphi)","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"To achieve this, let R(r phi) = r(sinphi + cosphi). Now, substituting some terms leads to","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_0^pi2 int_0^1(sinphi+cosphi) fleft( barr(rphi) right)  r  textdr  textdphi\n    = int_0^pi2 int_0^r_0 fleft( barr(rphi) right)  left(fracRsinphi + cosphiright)  textdr  textdphi","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"Since textdRtextdr = sinphi + cosphi, a change of integral domain leads to","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"int_0^pi2 int_0^r_0 fleft( barr(rphi) right)  left(fracRsinphi + cosphiright)  textdr  textdphi\n    = int_0^pi2 int_0^1 fleft( barr(Rphi) right)  left(fracRleft(sinphi + cosphiright)^2right)  textdR  textdphi","category":"page"},{"location":"triangle/","page":"Integrating a Triangle","title":"Integrating a Triangle","text":"The second term in this new integrand function serves as a correction factor that corrects for the impact of the non-linear domain transformation. Since all of the integration bounds are now constants, specialized integration methods can be defined for triangles that performs these domain transformations and then solve the new rectangular integration problem using a wider range of solver options.","category":"page"},{"location":"usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"usage/#Integrating-along-a-Bezier-curve","page":"Example Usage","title":"Integrating along a Bezier curve","text":"","category":"section"},{"location":"usage/","page":"Example Usage","title":"Example Usage","text":"using Meshes\nusing MeshIntegrals\n\n# Define a unit circle on the xy-plane\norigin = Point(0,0,0)\nzÌ‚ = Vec(0,0,1)\nxy_plane = Plane(origin,zÌ‚)\nunit_circle_xy = Circle(xy_plane, 1.0)\n\n# Approximate unit_circle_xy with a high-order Bezier curve\nunit_circle_bz = BezierCurve(\n    [Point(cos(t), sin(t), 0.0) for t in range(0,2pi,length=361)]\n)\n\n# A Real-valued function\nf(x, y, z) = abs(x + y)\nf(p) = f(to(p)...)\n\nintegral(f, unit_circle_xy, GaussKronrod())\n    # 0.000170 seconds (5.00 k allocations: 213.531 KiB)\n    # ans == 5.656854249525293 m^2\n\nintegral(f, unit_circle_bz, GaussKronrod())\n    # 0.017122 seconds (18.93 k allocations: 78.402 MiB)\n    # ans = 5.551055333711397 m^2","category":"page"},{"location":"supportmatrix/#Support-Matrix","page":"Support Matrix","title":"Support Matrix","text":"","category":"section"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"While this library aims to support all possible integration rules and Meshes.jl geometry types, some combinations are ill-suited and some others are simply not yet implemented. The following Support Matrix aims to capture the current development state of all geometry/rule combinations. Entries with a green check mark are fully supported and have passing unit tests that provide some confidence they produce accurate results.","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"In general, Gauss-Kronrod integration rules are recommended (and the default) for geometries with one parametric dimension, e.g.: Segment, BezierCurve, and Rope. Gauss-Kronrod rules can also be applied to some geometries with more dimensions by nesting multiple integration solves, but this is inefficient. These Gauss-Kronrod rules are supported (but not recommended) for surface-like geometries, but not for volume-like geometries. For geometries with more than one parametric dimension, e.g. surfaces and volumes, H-Adaptive Cubature integration rules are recommended (and the default).","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Symbol Support Level\nâœ… Supported, passes unit tests\nðŸŽ—ï¸ Planned to support in the future\nðŸ›‘ Not supported","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Meshes.Geometry Gauss-Legendre Gauss-Kronrod H-Adaptive Cubature\nBall in ð”¼{2} âœ… âœ… âœ…\nBall in ð”¼{3} âœ… ðŸ›‘ âœ…\nBezierCurve âœ… âœ… âœ…\nBox in ð”¼{1} âœ… âœ… âœ…\nBox in ð”¼{2} âœ… âœ… âœ…\nBox in ð”¼{â‰¥3} âœ… ðŸ›‘ âœ…\nCircle âœ… âœ… âœ…\nCone âœ… âœ… âœ…\nConeSurface âœ… âœ… âœ…\nCylinder âœ… ðŸ›‘ âœ…\nCylinderSurface âœ… âœ… âœ…\nDisk âœ… âœ… âœ…\nEllipsoid âœ… âœ… âœ…\nFrustum ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nFrustumSurface âœ… âœ… âœ…\nHexahedron âœ… âœ… âœ…\nLine âœ… âœ… âœ…\nParaboloidSurface âœ… âœ… âœ…\nParametrizedCurve âœ… âœ… âœ…\nPlane âœ… âœ… âœ…\nPolyarea ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nPyramid ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nQuadrangle âœ… âœ… âœ…\nRay âœ… âœ… âœ…\nRing âœ… âœ… âœ…\nRope âœ… âœ… âœ…\nSegment âœ… âœ… âœ…\nSimpleMesh ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nSphere in ð”¼{2} âœ… âœ… âœ…\nSphere in ð”¼{3} âœ… âœ… âœ…\nTetrahedron in ð”¼{3} ðŸŽ—ï¸ âœ… ðŸŽ—ï¸\nTriangle âœ… âœ… âœ…\nTorus âœ… âœ… âœ…\nWedge ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸","category":"page"},{"location":"#MeshIntegrals.jl","page":"About","title":"MeshIntegrals.jl","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: License: MIT) (Image: ColPrac)","category":"page"},{"location":"","page":"About","title":"About","text":"(Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA)","category":"page"},{"location":"","page":"About","title":"About","text":"MeshIntegrals.jl uses differential forms to enable fast and easy numerical integration of arbitrary integrand functions over domains defined via Meshes.jl geometries. This is achieved using:","category":"page"},{"location":"","page":"About","title":"About","text":"Gauss-Legendre quadrature rules from FastGaussQuadrature.jl: GaussLegendre(n)\nH-adaptive Gauss-Kronrod quadrature rules from QuadGK.jl: GaussKronrod(kwargs...)\nH-adaptive cubature rules from HCubature.jl: HAdaptiveCubature(kwargs...)","category":"page"},{"location":"","page":"About","title":"About","text":"These solvers have support for integrand functions that produce scalars, vectors, and Unitful.jl Quantity types. While HCubature.jl does not natively support Quantity type integrands, this package provides a compatibility layer to enable this feature.","category":"page"},{"location":"#Usage","page":"About","title":"Usage","text":"","category":"section"},{"location":"#Basic","page":"About","title":"Basic","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"integral(f, geometry)","category":"page"},{"location":"","page":"About","title":"About","text":"Performs a numerical integration of some integrand function f(p::Meshes.Point) over the domain specified by geometry. A default integration method will be automatically selected according to the geometry: GaussKronrod() for 1D, and HAdaptiveCubature() for all others.","category":"page"},{"location":"","page":"About","title":"About","text":"integral(f, geometry, rule)","category":"page"},{"location":"","page":"About","title":"About","text":"Performs a numerical integration of some integrand function f(p::Meshes.Point) over the domain specified by geometry using the specified integration rule, e.g. GaussKronrod().","category":"page"},{"location":"","page":"About","title":"About","text":"Additionally, several optional keyword arguments are defined in the API to provide additional control over the integration mechanics.","category":"page"},{"location":"#Aliases","page":"About","title":"Aliases","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"lineintegral(f, geometry)\nsurfaceintegral(f, geometry)\nvolumeintegral(f, geometry)","category":"page"},{"location":"","page":"About","title":"About","text":"Alias functions are provided for convenience. These are simply wrappers for integral that also validate that the provided geometry has the expected number of parametric dimensions. Like with integral, a rule can also optionally be specified as a third argument.","category":"page"},{"location":"","page":"About","title":"About","text":"lineintegral is used for curve-like geometries or polytopes (e.g. Segment, Ray, BezierCurve, Rope, etc)\nsurfaceintegral is used for surfaces (e.g. Disk, Sphere, CylinderSurface, etc)\nvolumeintegral is used for (3D) volumes (e.g. Ball, Cone, Torus, etc)","category":"page"},{"location":"how_it_works/#How-it-Works-(Work-in-Progress)","page":"How it Works","title":"How it Works (Work in Progress)","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"This page will explain how this package works by example...","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Let f be a function to be integrated throughout the volume bounded by a unit sphere. This integral is often expressed as simply","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"iiint f(x y z)  textdV","category":"page"},{"location":"how_it_works/#Parametric-Functions","page":"How it Works","title":"Parametric Functions","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"!TODO! update segment to Ball","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Every supported Meshes.Geometry type is defined as having a parametric function that maps from a local coordinate system to every point on the geometry. For example,","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"a = Meshes.Point(0, 0)\nb = Meshes.Point(2, 4)\nsegment = Meshes.Segment(a, b)","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"defines a line segment beginning at point a and ending at point b. As a geometry with one parametric dimension (i.e. paramdim(segment) == 1), it can be treated as a function with one argument that returns a corresponding point on the segment.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"segment(0) == a\nsegment(0.5) == Point(1, 2)\nsegment(1) == b","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"... where t is a parametric coordinate used to generate points in the domain.","category":"page"},{"location":"how_it_works/#Differential-Forms","page":"How it Works","title":"Differential Forms","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Using differential forms, the general solution for integrating a geometry with three parametric dimensions (t_1, t_2, and t_3) is","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"iiint f(x y z)  left textdt_1 wedge textdt_2 wedge textdt_3 right","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Since Meshes.Geometrys parametric functions have arguments that are defined on the domain 01, this is equivalent to","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"int_0^1 int_0^1 int_0^1 f(x y z)  left textdt_1 wedge textdt_2 wedge textdt_3 right","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"For every point in the integration domain where the integrand function is evaluated, the differential element textdt_1 wedge textdt_2 is calculated using the Jacobian of the parametric function. For a two-dimensional surface this Jacobian consists of two vectors, each pointing in the direction that the parametric function's output point will move by changing each input argument. The differential element, then, is simply the magnitude of the exterior product of these vectors.","category":"page"}]
}
