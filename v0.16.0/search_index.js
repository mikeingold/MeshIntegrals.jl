var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = MeshIntegrals","category":"page"},{"location":"api/#Integrals","page":"Public API","title":"Integrals","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integral.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.integral","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, geometry[, rule]; diff_method=_default_diff_method(geometry, FP), FP=Float64)\n\nNumerically integrate a given function f(::Point) over the domain defined by a geometry using a particular numerical integration rule with floating point precision of type FP.\n\nArguments\n\nf: an integrand function, i.e. any callable with a method f(::Meshes.Point)\ngeometry: some Meshes.Geometry that defines the integration domain\nrule: optionally, the IntegrationRule used for integration (by default\n\nGaussKronrod() in 1D and HAdaptiveCubature() else)\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = _default_diff_method(geometry, FP): the method to\n\nuse for calculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired.\n\n\n\n\n\n","category":"function"},{"location":"api/#Specializations","page":"Public API","title":"Specializations","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = Main.SPECIALIZATIONS_FILES","category":"page"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{T}, Tuple{DM}, Tuple{Any, Meshes.BezierCurve, IntegrationRule}} where {DM<:DifferentiationMethod, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, curve::BezierCurve, rule = GaussKronrod();\n         diff_method=Analytical(), FP=Float64, alg=Meshes.Horner())\n\nLike integral but integrates along the domain defined by curve.\n\nArguments\n\nf: an integrand function, i.e. any callable with a method f(::Meshes.Point)\ncurve: a Meshes.BezierCurve that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = Analytical(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\nalg = Meshes.Horner():  the method to use for parametrizing curve. Alternatively,\n\nalg=Meshes.DeCasteljau() can be specified for increased accuracy, but comes with a steep performance cost, especially for curves with a large number of control points.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{Any, Meshes.Ring, I}} where I<:IntegrationRule","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, ring::Ring, rule = GaussKronrod();\n         diff_method=FiniteDifference(), FP=Float64)\n\nLike integral but integrates along the domain defined by ring. The specified integration rule is applied independently to each segment formed by consecutive points in the Ring.\n\nArguments\n\nf: an integrand function, i.e. any callable with a method f(::Meshes.Point)\nring: a Ring that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = FiniteDifference(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{Any, Meshes.Rope, I}} where I<:IntegrationRule","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, rope::Rope, rule = GaussKronrod();\n         diff_method=FiniteDifference(), FP=Float64)\n\nLike integral but integrates along the domain defined by rope. The specified integration rule is applied independently to each segment formed by consecutive points in the Rope.\n\nArguments\n\nf: an integrand function, i.e. any callable with a method f(::Meshes.Point)\nrope: a Rope that defines the integration domain\nrule = GaussKronrod(): optionally, the IntegrationRule used for integration\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod = FiniteDifference(): the method to use for\n\ncalculating Jacobians that are used to calculate differential elements\n\nFP = Float64: the floating point precision desired\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals._ParametricGeometry","page":"Public API","title":"MeshIntegrals._ParametricGeometry","text":"_ParametricGeometry <: Meshes.Primitive <: Meshes.Geometry\n\n_ParametricGeometry is used internally in MeshIntegrals.jl to behave like a generic wrapper for geometries with custom parametric functions. This type is used for transforming other geometries to enable integration over the standard rectangular [0,1]^n domain.\n\nMeshes.jl adopted a ParametrizedCurve type that performs a similar role as of v0.51.20, but only supports geometries with one parametric dimension. Support is additionally planned for more types that span surfaces and volumes, at which time this custom type will probably no longer be required.\n\nFields\n\nfun - anything callable representing a parametric function: (ts...) -> Meshes.Point\n\nType Structure\n\nM <: Meshes.Manifold - same usage as in Meshes.Geometry{M, C}\nC <: CoordRefSystems.CRS - same usage as in Meshes.Geometry{M, C}\nF - type of the callable parametric function\nDim - number of parametric dimensions\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals._ParametricGeometry-Tuple{Any, Int64}","page":"Public API","title":"MeshIntegrals._ParametricGeometry","text":"_ParametricGeometry(fun, dims)\n\nConstruct a _ParametricGeometry using a provided parametric function fun for a geometry with dims parametric dimensions.\n\nArguments\n\nfun - anything callable representing a parametric function mapping (ts...) -> Meshes.Point\ndims::Int64 - number of parametric dimensions, i.e. length(ts)\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals._parametric","page":"Public API","title":"MeshIntegrals._parametric","text":"_parametric(geometry::G) where {G <: Meshes.Geometry} -> Function\n\nUsed in MeshIntegrals.jl for defining parametric functions that transform non-standard geometries into a form that can be integrated over the standard rectangular [0,1]^n limits.\n\n\n\n\n\n","category":"function"},{"location":"api/#Aliases","page":"Public API","title":"Aliases","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integral_aliases.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.lineintegral","page":"Public API","title":"MeshIntegrals.lineintegral","text":"lineintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a line-like geometry using a particular numerical integration rule with floating point precision of type FP.\n\nRule types available:\n\nGaussKronrod (default)\nGaussLegendre\nHAdaptiveCubature\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.surfaceintegral","page":"Public API","title":"MeshIntegrals.surfaceintegral","text":"surfaceintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a surface geometry using a particular numerical integration rule with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.volumeintegral","page":"Public API","title":"MeshIntegrals.volumeintegral","text":"volumeintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) throughout a volumetric geometry using a particular numerical integration rule with floating point precision of type FP.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-Rules","page":"Public API","title":"Integration Rules","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"integration_rules.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.GaussKronrod","page":"Public API","title":"MeshIntegrals.GaussKronrod","text":"GaussKronrod(kwargs...)\n\nThe h-adaptive Gauss-Kronrod quadrature rule implemented by QuadGK.jl. All standard QuadGK.quadgk keyword arguments are supported. This rule works natively for one dimensional geometries; some two- and three-dimensional geometries are additionally supported using nested integral solvers with the specified kwarg settings.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.GaussLegendre","page":"Public API","title":"MeshIntegrals.GaussLegendre","text":"GaussLegendre(n)\n\nAn n'th-order Gauss-Legendre quadrature rule. Nodes and weights are efficiently calculated using FastGaussQuadrature.jl.\n\nSo long as the integrand function can be well-approximated by a polynomial of order 2n-1, this method should yield results with 16-digit accuracy in O(n) time. If the function is know to have some periodic content, then n should (at a minimum) be greater than the expected number of periods over the geometry, e.g. length(geometry)/Î».\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.HAdaptiveCubature","page":"Public API","title":"MeshIntegrals.HAdaptiveCubature","text":"HAdaptiveCubature(kwargs...)\n\nThe h-adaptive cubature rule implemented by HCubature.jl. All standard HCubature.hcubature keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#Derivatives","page":"Public API","title":"Derivatives","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [MeshIntegrals]\nPages = [\"differentiation.jl\"]","category":"page"},{"location":"api/#MeshIntegrals.AutoEnzyme","page":"Public API","title":"MeshIntegrals.AutoEnzyme","text":"AutoEnzyme()\n\nUse to specify use of the Enzyme.jl for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.DifferentiationMethod","page":"Public API","title":"MeshIntegrals.DifferentiationMethod","text":"DifferentiationMethod\n\nA category of types used to specify the desired method for calculating derivatives. Derivatives are used to form Jacobian matrices when calculating the differential element size throughout the integration region.\n\nSee also FiniteDifference, AutoEnzyme.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.FiniteDifference","page":"Public API","title":"MeshIntegrals.FiniteDifference","text":"FiniteDifference(Îµ=1e-6)\n\nUse to specify use of a finite-difference approximation method with a step size of Îµ for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.differential-Union{Tuple{T}, Tuple{G}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}, DifferentiationMethod}} where {G<:Meshes.Geometry, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.differential","text":"differential(geometry, ts[, diff_method])\n\nCalculate the differential element (length, area, volume, etc) of the parametric function for geometry at arguments ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.jacobian-Union{Tuple{T}, Tuple{G}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}}} where {G<:Meshes.Geometry, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.jacobian","text":"jacobian(geometry, ts[, diff_method])\n\nCalculate the Jacobian of a geometry's parametric function at some point ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"usage/#Integrating-along-a-Bezier-curve","page":"Example Usage","title":"Integrating along a Bezier curve","text":"","category":"section"},{"location":"usage/","page":"Example Usage","title":"Example Usage","text":"using Meshes\nusing MeshIntegrals\n\n# Define a unit circle on the xy-plane\norigin = Point(0,0,0)\nzÌ‚ = Vec(0,0,1)\nxy_plane = Plane(origin,zÌ‚)\nunit_circle_xy = Circle(xy_plane, 1.0)\n\n# Approximate unit_circle_xy with a high-order Bezier curve\nunit_circle_bz = BezierCurve(\n    [Point(cos(t), sin(t), 0.0) for t in range(0,2pi,length=361)]\n)\n\n# A Real-valued function\nf(x, y, z) = abs(x + y)\nf(p) = f(to(p)...)\n\nintegral(f, unit_circle_xy, GaussKronrod())\n    # 0.000170 seconds (5.00 k allocations: 213.531 KiB)\n    # ans == 5.656854249525293 m^2\n\nintegral(f, unit_circle_bz, GaussKronrod())\n    # 0.017122 seconds (18.93 k allocations: 78.402 MiB)\n    # ans = 5.551055333711397 m^2","category":"page"},{"location":"supportmatrix/#Support-Matrix","page":"Support Matrix","title":"Support Matrix","text":"","category":"section"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"This library aims to enable users to calculate the value of integrals over all Meshes.jl geometry types using an array of numerical integration rules and techniques. However, some combinations of geometry types and integration rules are ill-suited, and some others are simply not yet implemented. The following Support Matrix captures the current state of support for all geometry/rule combinations. Entries with a green check mark are fully supported and pass unit tests designed to check for accuracy.","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"In general, Gauss-Kronrod integration rules are recommended (and the default) for geometries with one parametric dimension, e.g.: Segment, BezierCurve, and Rope. For geometries with more than one parametric dimension, e.g. surfaces and volumes, H-Adaptive Cubature rules are recommended (and the default).","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"While it is possible to apply nested Gauss-Kronrod rules to numerically integrate geometries with more than one parametric dimension, this produces results that are strictly inferior to using an equivalent H-Adaptive Cubature rule, so support for this usage is not recommended.","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Symbol Support Level\nâœ… Supported\nðŸŽ—ï¸ Planned to support in the future\nâš ï¸ Deprecated\nðŸ›‘ Not supported","category":"page"},{"location":"supportmatrix/","page":"Support Matrix","title":"Support Matrix","text":"Meshes.Geometry Gauss-Legendre Gauss-Kronrod H-Adaptive Cubature\nBall in ð”¼{2} âœ… âš ï¸ âœ…\nBall in ð”¼{3} âœ… ðŸ›‘ âœ…\nBezierCurve âœ… âœ… âœ…\nBox in ð”¼{1} âœ… âœ… âœ…\nBox in ð”¼{2} âœ… âš ï¸ âœ…\nBox in ð”¼{â‰¥3} âœ… ðŸ›‘ âœ…\nCircle âœ… âœ… âœ…\nCone âœ… ðŸ›‘ âœ…\nConeSurface âœ… âš ï¸ âœ…\nCylinder âœ… ðŸ›‘ âœ…\nCylinderSurface âœ… âš ï¸ âœ…\nDisk âœ… âš ï¸ âœ…\nEllipsoid âœ… âœ… âœ…\nFrustum ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nFrustumSurface âœ… âš ï¸ âœ…\nHexahedron âœ… âœ… âœ…\nLine âœ… âœ… âœ…\nParaboloidSurface âœ… âš ï¸ âœ…\nParametrizedCurve âœ… âœ… âœ…\nPlane âœ… âœ… âœ…\nPolyarea ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nPyramid ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nQuadrangle âœ… âš ï¸ âœ…\nRay âœ… âœ… âœ…\nRing âœ… âœ… âœ…\nRope âœ… âœ… âœ…\nSegment âœ… âœ… âœ…\nSimpleMesh ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸\nSphere in ð”¼{2} âœ… âœ… âœ…\nSphere in ð”¼{3} âœ… âš ï¸ âœ…\nTetrahedron âœ… âš ï¸ âœ…\nTriangle âœ… âœ… âœ…\nTorus âœ… âš ï¸ âœ…\nWedge ðŸŽ—ï¸ ðŸŽ—ï¸ ðŸŽ—ï¸","category":"page"},{"location":"#MeshIntegrals.jl","page":"About","title":"MeshIntegrals.jl","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: License: MIT) (Image: ColPrac)","category":"page"},{"location":"","page":"About","title":"About","text":"(Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA)","category":"page"},{"location":"","page":"About","title":"About","text":"MeshIntegrals.jl uses differential forms to enable fast and easy numerical integration of arbitrary integrand functions over domains defined via Meshes.jl geometries. This is achieved using:","category":"page"},{"location":"","page":"About","title":"About","text":"Gauss-Legendre quadrature rules from FastGaussQuadrature.jl: GaussLegendre(n)\nH-adaptive Gauss-Kronrod quadrature rules from QuadGK.jl: GaussKronrod(kwargs...)\nH-adaptive cubature rules from HCubature.jl: HAdaptiveCubature(kwargs...)","category":"page"},{"location":"","page":"About","title":"About","text":"These solvers have support for integrand functions that produce scalars, vectors, and Unitful.jl Quantity types. While HCubature.jl does not natively support Quantity type integrands, this package provides a compatibility layer to enable this feature.","category":"page"},{"location":"#Usage","page":"About","title":"Usage","text":"","category":"section"},{"location":"#Basic","page":"About","title":"Basic","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"integral(f, geometry)","category":"page"},{"location":"","page":"About","title":"About","text":"Performs a numerical integration of some integrand function f over the domain specified by geometry. The integrand function can be anything callable with a method f(::Meshes.Point). A default integration method will be automatically selected according to the geometry: GaussKronrod() for 1D, and HAdaptiveCubature() for all others.","category":"page"},{"location":"","page":"About","title":"About","text":"integral(f, geometry, rule)","category":"page"},{"location":"","page":"About","title":"About","text":"Performs a numerical integration of some integrand function f over the domain specified by geometry using the specified integration rule, e.g. GaussKronrod(). The integrand function can be anything callable with a method f(::Meshes.Point).","category":"page"},{"location":"","page":"About","title":"About","text":"Additionally, several optional keyword arguments are defined in the API to provide additional control over the integration mechanics.","category":"page"},{"location":"#Aliases","page":"About","title":"Aliases","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"lineintegral(f, geometry)\nsurfaceintegral(f, geometry)\nvolumeintegral(f, geometry)","category":"page"},{"location":"","page":"About","title":"About","text":"Alias functions are provided for convenience. These are simply wrappers for integral that also validate that the provided geometry has the expected number of parametric dimensions. Like with integral, a rule can also optionally be specified as a third argument.","category":"page"},{"location":"","page":"About","title":"About","text":"lineintegral is used for curve-like geometries or polytopes (e.g. Segment, Ray, BezierCurve, Rope, etc)\nsurfaceintegral is used for surfaces (e.g. Disk, Sphere, CylinderSurface, etc)\nvolumeintegral is used for (3D) volumes (e.g. Ball, Cone, Torus, etc)","category":"page"},{"location":"how_it_works/#How-it-Works-(By-Example)","page":"How it Works","title":"How it Works (By Example)","text":"","category":"section"},{"location":"how_it_works/#Example-Problem","page":"How it Works","title":"Example Problem","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Let f be a function of position barr in some space.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"function f(rÌ„::Meshes.Point)\n    x, y, z = to(rÌ„)\n    ...\nend","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Let the integration domain be the space (a ball) enclosed by a sphere centered on the origin with a radius of 5 meters.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"center = Meshes.Point(0u\"m\", 0u\"m\", 0u\"m\")\nradius = 5.0u\"m\"\nball = Meshes.Ball(center, radius)","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"This integral is often expressed abstractly as simply the following, where the triple integral signs and textdV indicate that the integration domain is some three-dimensional volume.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"iiint f(barr)  textdV","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Integrals like this are often solved manually by selecting an appropriate coordinate system and limits that neatly represent the integration domain, e.g.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"int_0^pi int_0^2pi int_0^5 f(barr)  textdrhotextdthetatextdphi","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"This works great for simple geometries, but requires integration code that is geometry-specific. This package leverages parametric functions defined in Meshes.jl and differential forms to define integral methods that are general solutions for all geometries.","category":"page"},{"location":"how_it_works/#how-parametric","page":"How it Works","title":"Parametric Functions","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Every supported Meshes.Geometry type is defined as having a parametric function that maps from a local parametric coordinate system to every point on the geometry. Curve-like geometries will have a single parametric dimension, surfaces will have two dimensions, and volumes will have three dimensions; this can be checked for a particular geometry via Meshes.paramdim(geometry).","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"For consistency across geometry types, with some notable exceptions, these parametric functions are defined to take coordinates inside a normalized range 01. In the example case of ball, Meshes.jl defines a parametric function mapped in normalized spherical coordinates (t_rho t_theta t_phi). We find, then:","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Meshes.paramdim(ball) == 3    # a volume\n\nball(tÏ, tÎ¸, tÏ†)    # for args in range [0, 1], maps to a corresponding Meshes.Point\n\nball(0, tÎ¸, tÏ†) == center","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"In effect, we can now use the geometry itself as a function that maps from three normalized (0 le t le 1) arguments to every point on the geometry. For the sake of generalization, let this parametric function be called g.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"textg (t_1t_2t_3) mapsto textPointbig x y z big  ","category":"page"},{"location":"how_it_works/#Differential-Forms","page":"How it Works","title":"Differential Forms","text":"","category":"section"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Using differential forms, the general solution for integrating a geometry with three parametric dimensions (t_1, t_2, and t_3) is","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"iiint f(r)  textdV = iiint f(barr)  bartextdt_1 wedge bartextdt_2 wedge bartextdt_3","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"This resultant differential (volume) element is formed at each point in the integration domain by taking the Jacobian of the parametric function.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"mathbfJ_f = beginbmatrix bartextdt_1  bartextdt_2  bartextdt_3 endbmatrix","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"where","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"bartextdt_n = fracpartialpartial t_n  textg(t_1t_2t_3)","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Each of these partial derivatives is a vector representing the direction that changing each parametric function argument will move the resultant point. The differential element (E) size is then calculated using geometric algebra as the magnitude of the exterior product (wedge) of these three vectors.","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"E(t_1t_2t_3) = left bartextdt_1 wedge bartextdt_2 wedge bartextdt_3 right","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"Finally, we use the parametric function itself, g, as a map to all points barr in the integration domain. Since Meshes.Geometry parametric functions all operate on normalized domains, we can now solve any volume integral as simply","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"int_0^1 int_0^1 int_0^1 fBig(textgbig(t_1t_2t_3big)Big)  E(t_1t_2t_3)  textdt_1  textdt_2  textdt_3","category":"page"},{"location":"how_it_works/","page":"How it Works","title":"How it Works","text":"This form of integral can be trivially generalized to support n-dimensional geometries in a form that enables the use of a wide range of numerical integration libraries.","category":"page"},{"location":"specializations/#specializations","page":"Specializations","title":"Specializations","text":"","category":"section"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"There are several notable exceptions to how Meshes.jl defines parametric functions.","category":"page"},{"location":"specializations/","page":"Specializations","title":"Specializations","text":"Meshes.ConeSurface is essentially a composite type and has a parametric function that only maps the conical portion of the geometry, so the Meshes.Disk base element has to be integrated separately.\nMeshes.CylinderSurface is essentially a composite type and has a parametric function that only maps the cylindrical portion of the geometry, so the Meshes.Disk element has to be integrated separately.\nMeshes.FrustumSurface is essentially a composite type and has a parametric function that only maps the cylindrical portion of the geometry, so the top and bottom Meshes.Disk elements have to be integrated separately.\nMeshes.Line represents a line of infinite length that passes through two points, and it has a parametric function that is valid on the domain (-infty infty).\nMeshes.Plane represents a plane of infinite extent, and it has a parametric function that is valid on the domain (-infty infty)^2.\nMeshes.Ray represents a line that begins at a point and extends in a particular direction with infinite length, and it has a parametric function that is valid on the domain 0 infty).\nMeshes.Ring is a composite type that lacks a parametric function, but can be decomposed into Meshes.Segments and then integrated by adding together the individual integrals.\nMeshes.Rope is a composite type that lacks a parametric function, but can be decomposed into Meshes.Segments and then integrated by adding together the individual integrals.\nMeshes.Triangle has a parametric function that takes coordinates on a 2D barycentric coordinate system. So, for (::Meshes.Triangle)(t1, t2), the coordinates must obey: t_1 t_2 in 01 where t_1 + t_2 le 1.\nMeshes.Tetrahedron has a parametric function that takes coordinates on a 3D barycentric coordinate system. So, for (::Meshes.Tetrahedron)(t1, t2), the coordinates must obey: t_1 t_2 t_3 in 01 where t_1 + t_2 + t_3 le 1.","category":"page"}]
}
